
.\" Manpage for _printf.
.TH _printf 3 "15 April 2022" "1.0" "Program Manual for _printf"
.SH NAME
 _printf - formatted output conversion and print data.
.SH SYNOPSIS
.nf
.BI printf (FORMAT, ARGUMENT)...
.PP
.BI "#include 'main.h'
.BI "#include <stdarg.h>"
.BI "#include <unistd.h>"
.PP
.BI "int _printf(const char *format, ...);"
.BI "int print_prg(va_list __attribute__((unused)), char *, unsigned int);"
.BI "int print_chr(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_str(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_int(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_bnr(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_unt(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_oct(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_hex(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_upx(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_usr(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_add(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_rev(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int print_rot(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinlint(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinlunt(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinloct(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinlhex(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinlupx(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinhint(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinhunt(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinhoct(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinhhex(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinhupx(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinpint(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinnoct(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinnhex(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinnupx(va_list arguments, char *buf, unsigned int ibuf);"
.BI "int prinsint(va_list arguments, char *buf, unsigned int ibuf);"
.PP
.BI "int (*get_print_func(const char *s, int index))(va_list, char *, unsigned int);"
.BI "int ev_print_func(const char *s, int index);"
.PP
.BI "unsigned int handl_buf(char *buf, char c, unsigned int ibuf);"
.BI "int print_buf(char *buf, unsigned int nbuf);"
.PP
.BI "char *fill_binary_array(char *binary, long int int_in, int isneg, int limit);"
.BI "char *fill_oct_array(char *bnr, char *oct);"
.BI "char *fill_long_oct_array(char *bnr, char *oct);"
.BI "char *fill_short_oct_array(char *bnr, char *oct);"
.BI "char *fill_hex_array(char *bnr, char *hex, int isupp, int limit);"
.PP
.SH DESCRIPTION
The output function _printf() produce output according to a format. the function _printf converts the character strings that receives as argument and prints it on the standard output.
.SH RETURN VALUE
Returns the number of all the characters printed, excluding the NULL byte used to end output to strings.
.SH Format String Format
The format string is a character string, which contains two types of directives: ordinary characters which are coppied to the output stream; and conversion specifiers. Each conversion specification is introduced by the character %, and ends with a conversion specifier.
.SH Conversion Specifiers
This are the characters that specifies the type of conversion to be applied. The conversion specifiers and their meanings are: 
.TP
.B c
.R The \fIint\fR argument is converted to an \fIunsigned char\fR, and the resulting character is written.
.TP
.B s
.R The \fIconst char *\fR argument is a pointer to an array of characters, that converts the corresponding argument to a character string.
.TP
.B d, i
.R The \fIint\fR argument is converted to signed decimal notation.
.TP
.B o, u, x, X
.R The \fIunsigned int\fR argument is converted to unsigned octal \fIo\fR (base 8 number), unsigned decimal \fIu\fR (base 10 number), unsigned hexadecimal \fIx\fR (base 16 number with lowercase letters) and unsigned hexadecimal \fIX\fR (base 16 number with uppercase letters).
.TP
.B %, %%
.R If only the \fI%\fR character is written no argument is converted. The complete conversion specification is \fI%%\fR, that returns the actual sign if there in front.
.TP
.B S
.R The \fIconst char\fR argument is a pointer to an array of characters, that converts the corresponding argument to a character st\
ring, with non-printable characters (0 < ASCII value < 32 or >= 127).
.TP
.B p
.R The \fIvoid * pointer\fR argument is printed in hexadecimal.
.TP
.B S
.R The \fIconst char\fR argument is a pointer to an array
.SH The flag characters
The character \fI%\fR is followed by zero the following flags:
.TP
.B +
.R A sign \fI+\fR or \fI-\fR will be placed before a number followed by a signed conversion.
.TP
.B #
.R Print number in hexadecimal, upeercase hexadecimal and octal where the first character of the output string is made zero.
.TP
.B ' '
.R A space in blank should be left before a positive number followed by a signed conversion.
.SH NOTES.R A space in blank should be left before a positive number followed by a signed conversion.
.SH NOTES
.R The \fB_printf()\fR is a project collaboration between \fBIsrael Adenuga\fR and \fBChidozie Ogwalu\fR, actual students of Software Engineering at \fBHolberton School\fR.
.SH BUGS
.R In process
.SH EXAMPLE
.R To print the the string \fBHello Holberton!\fR and its length in decimal.

#include ''holberton.h''
=======
.TH _PRINTF 3  "Holberton School 0x11. C - _printf"

.SH NAME
.B _printf\fR \- formatted output conversion

.SH SYNOPSIS
.B #include \fB"main.h"

.B int printf(const char *\fIformat\fB, ...);

.SH DESCRIPTION
The function \fB_printf()\fR writes output to \fIstdout\fR, the standard
output. The function writes under the control of a \fIformat\fR string that
specifies how subsequent arguments (accessed via the variable-length argument
facilities of stdarg) are converted for output.

.B Return value
.in +2n
Upon successful return, \fB_printf()\fR returns the number of characters
printed (excluding the null byte used to end output to strings).

If an output error is encountered, -1 is returned.
.in

.B Format of the format string
.in +2n
The format string is a constant character string composed of zero or more
directives: ordinary characters (not \fB%\fR) which are copied unchanged to
the output stream; and conversion specifications, each of which results in
fetching zero or more subsequent arguments. Conversion specification is
introduced by the character \fB%\fR and ends with a \fIconversion specifier\fR.

In between the \fB%\fR character and conversion specifier, there may be (in
order) zero or more \fIflags\fR, an optional minimum \fIfield width\fR, an
optional \fIprecision\fR and an optional \fIlength\fR modifier. The arguments
must correspond with the conversion specifier, and are used in the order given.
.in

.B Flag Characters
.in +2n
The character \fB%\fR may be followed by zero or more of the following flags:

.RS
.B #
.in +2n
For \fBo\fR conversions, the first character of the output string is prefixed
with 0 if it was not zero already. For x and X converions, 0x or 0X,
respectively, is prepended for non-zero numbers.
.in
.RE

.RS
.B ''
.in +2n
(space) A blank is left before a positive number or empty string produced by a
signed conversion.
.in
.RE

.RS
.B +
.in +2n
A sign (+ or -) is always placed before a number produced by signed conversion.
.in
.RE

.RS
.B 0
.in +2n
For \fBd\fR, \fBi\fR, \fBo\fR, \fBu\fR, \fBx\fR, and \fBX\fR conversions, the
converted value is padded on the left with zeroes rather than blanks. If the
\fB0\fR flag is provided to a numeric conversion with a specified precision,
it is ignored.
.in
.RE

.RS
.B -
.in +2n
The converted value is left-justified (padded on the right with blanks instead
of on the left with blanks or zeroes). Overrides a \fB0\fR flag.
.in
.RE

.B Field Width
.in +2n
After flags, a minimum field width may be specified by a decimal digit string.
The first digit must be non-zero. If the converted value has fewer characters
than the provided width, the output is padded on the left or right with spaces
(depending on whether the \fB-\fR flag was provided).

Alternatively, width may be provied as an argument using the '*' character.
For example, in the following:
.in

.in +2n
_printf("%*d\\n", 6, 1);
.in

.in +2nn
the argument 6 is considered the width for the conversion of the decimal 1.
.in

.B Precision
.in +2n
After any flags or provided width, a precision may be specified by a '.'
followed by a decimal digit string. For \fBd\fR, \fBi\fR, \fBo\fR, \fBu\fR,
\fBx\fR, and \fBX\fR conversions, the precision specifies the minimum number
of digits to appear. For \fBs\fR and \fBS\fR conversions, the precision
specifies the maximum characters to be printed.

Alternatively, precision may be provided as an argument using the '*' character
after the '.'. For example, in the following:
.in

.in +2n
_printf("%.*d\\n", 6, 1);
.in

.in +2n
the argument 6 is considered the precision for the conversion of the decimal 1.
.in

.B Conversion Specifiers
.in +2n
A character that specifies the type of conversion to be applied. The
conversion specifiers and their meaning are:

.RS
.B d, i
.in +2n
The \fIint\fR argument is converted to signed decimal notation.
.in
.RE

.RS
.B b
.in +2n
The \fIunsigned int\fR argument is converted to binary.
.in
.RE

.RS
.B o, u, x, X
.in +2n
The \fIunsigned int\fR argument is converted to unsigned octal (\fBo\fR),
unsigned decimal (\fBu\fR), or unsigned hexadecimal (\fBx\fR and \fBX\fR)
notation. The letters \fBabcdef\fR are used for \fBx\fR conversions; the
letters \fBABCDEF\fR are used for \fBX\fR conversions.
.in
.RE

.RS
.B c
.in +2n
The \fIint\fR argument is converted to an \fIunsigned char\fR, and the
resulting character is written.
.in
.RE

.RS
.B s
.in +2n
The \fIconst char *\fR argument is expected to be a pointer to a character
array (pointer to a string). Characters from the array are written starting
from the first element of the array and ending at, but not including, the
terminating null byte ('\\0').
.in
.RE

.RS
.B S
.in +2n
Identical to the \fBS\fR conversion specifier, except any non-printable
characters in the array (ie. characters with an ASCII value < 32 or >= 127)
are written as \fB\\x\fR followed by the ASCII code value in hexadecimal
(upper case, two characters).
.in
.RE

.RS
.B r
.in +2n
Identical to the \fBs\fR conversion specifier, except characters from the
array are written in reverse, starting from (but not including) the
terminating null byte ('\\0') and ending at the first element of the array.
.in
.RE

.RS
.B R
.in +2n
Identical to the \fBs\fR conversion specifier, except each character of the
array is converted to its corresponding character in ROT13 before breing written.
.in
.RE

.RS
.B p
.in +2n
The address of the argument is written. The address is written in hexadecimal
with a leading \fI0x\fR.
.in
.RE

.RS
.B %
.in +2n
A '%' is written. No argument is converted. The complete conversion
specification is '%%'.
.in
.RE

.SH BUGS
Code such as \fB_printf(\fIfoo\fB);\fR possibly indicates a bug, since
\fIfoo\fR may contain a % character.

.SH EXAMPLE
To print the address of Holberton School in the form "972 Mission St., San
Francisco, CA 94103", followed by a new line, where \fIstreet\fR, \fIcity\fR,
and \fIstate\fR are pointers to strings:

.RS
#include "main.h"
>>>>>>> 89973819a6889c2a49d0f3c069ab71e4b11c1939

int main(void)

{

<<<<<<< HEAD
	int length;

	_printf(''%s'', ''Hello, Holberton!'')

	_printf(''Hello Holberton! contains %d characters'', length);

	length = _printf(''Hello Holberton!'');

	return (0);

}
.SH SEE ALSO
.R printf(3)
.SH AUTHORS
Written by \fBIsrael Adenuga\fR and \fBChidozie Ogwalu\fR.
=======
	char *street = "Mission St.";

	char *city = "San Francisco",

	char *state = "CA";

	printf("%d %s, %s, %s, %d\\n", 972, street, city, state, 94103);

}
.RE

To print the result of basic mathematical operations prepended by signs and
all numbers printed with a minimum precision of two digits:

.RS
#include "main.h"

int main(void)

{

	_printf("%.2d + %.2d = %+.2d\\n", 1, 2, 1 + 2);

	_printf("%d - %d = %+d\\n", 10, 20, 10 - 20);

}
.RE

To print the values of LONG_MAX and LONG_MIN aligned and
left-justified with a width of 30:

.RS
#include "main.h"

#include <limits.h>

int main(void)

{

	_printf("% -30ld -> LONG_MAX\\n", LONG_MAX);

	_printf("%-30ld -> LONG_MIN\\n", LONG_MIN);

}
.RE

.SH SEE ALSO
printf(3)

The \fB_printf()\fR function emulates functionality of the C standard library
function \fBprintf()\fR. This man page borrows from the corresponding Linux
man page printf(3).

.SH AUTHOR CREDIT
Arsene Awounou Pericles Adjovi
